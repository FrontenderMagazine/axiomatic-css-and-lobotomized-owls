# Аксиоматический CSS и лоботомированные совы.

На последнем [CSS Day][1] в июне я с трепетом представил странный трехсимвольный 
css-селектор. Он назывался «лоботомированная сова» из за его сходства с пустым
взглядом взглядом этой птички и это оказалась самая популярная часть [моего доклада][2].

Я не могу сказать что вызывало их восторг, идея или, напротив, они нервно 
хохотали над дерзостью использования столь странной и очевидно бесполезной 
конструкции. Или возможно я невольно оказался в комнате полной совопоклонниками. 
Не знаю.

Селектор лоботомированной совы выглядит так:

    * + *

Несмотря на непочтительное имя и сомнительную форму, селектор лоботимированной 
совы это не просто игра ума. Это результат продолжительных экспериментов с 
автоматизацией лаяутов с поточным контентом. Совоселектор это аксиоматичный 
жадный селектор. Ввиду этого многие усомнятся в целесообразности
его использования, а то, что я использовал его на продакшене кого то и вовсе 
повергнет в ужас. Но сейчас я продемонстрирую как этот селектор упростит код, 
ускорит процесс разработки и поможет автоматизировать произвольный, динамический
контент.


## Стилизация по умолчанию

Почти повсеместно, профессиональные дизайнеры веб-интерфейсов (хорошо, 
разработчики, или как вам там будет угодно) приучили себя стилизировать
HTML элементы *по умолчанию*. Мы представляем себе элемент интерфейса и затем
соответствующим образом стилизируем элемент, который вручную добавляем в разметку. 

Чаще всего мы используем для этого селектор по классу, несмотря на то что он 
отвечает только за представление, а не семантическое соответствие. В то время, 
как элементы и большинство атрибутов предопределены и стандартизированы, классы
предоставляют нам свободу творчества. Классы дают нам контроль.

    .my-module {
      /* ... */
    }

CSS фреймворки это в основном библиотеки нестандартизированных, основанных на 
классах, кодов, предназначенных для того, что бы сформировать явное соответствие 
между стилями и элементами, к которым они применяются. Их хвалят за то, что с их 
помощью дизайнеры могут быстро создавать привлекательные внешне интерфейсы и 
критикуют за неизбежные недостатки в области их доступности, которые проистекают
из того, что основным является представление (форма), а не контент (функция).
    
    <a class="ui-button">Нажми меня</a>

Вне зависимости от того, что вы используете — фреймворк или собственную 
методологию, такой подход не позволяет подключать к работе далеких от техники
контент-редакторов. Он требует не только знания разметки, отвечающей за 
представление, но и доступа к ней, что бы соответствующим образом разметить
контент. WYSIWYG-редакторы и инструменты вроде маркдауна определенно недостаточно
сложны для того, что бы необходимость стилизации не усложняла работу с материалами.


## Разрастание кода

Вне зависимости от того можешь ли ты создать и поддерживать разметку, отвечающую
за представление, остается вопрос *а надо ли*. Добавление шифров, отвечающие за 
представление в изначально лаконичную разметку непременно приведет к её разрастанию, 
но что мы получим в замен? Это позволит нам упростить таблицы стилей?

Выбрав стилизацию полностью на основе элементов мы ошибочно предполагаем что HTML
элементы существуют в вакууме, а не являются объектом наследования и не 
принадлежат своему контексту. Рассматривая элемент как «штуку для которой надо
написать стили» мы наделяем конкретный элемент избыточным значением и определяем
для него стили, которые должны были быть определены выше в каскаде. Добавление
новых модулей в проект приводит к неконтролируемому разрастанию кода. 


    .module-new {
      /* И … что в нем нового? */
    }

Что касается препроцессоров с их одержимостью переменными и 
объектно-ориентированными CSS-методологиями, их переиспользуемыми объектами
классов — с их помощью мы сбрасываем балласт что бы остановить разрастание кода.
Это одержимость нашей индустрии. Однако большинство из них навязывают философию,
которая, в первую очередь, и порождает разрастание кода. Некоторые из них даже
навязывают плоскую структуру css, цитируя [решение проблемы веса селекторов][3] —
эффективен переход от CSS к SS (*От каскадных таблиц стилей к просто 
таблицам стилей. Без использования каскада. __Примечание переводчика.__*) и 
отказ от одного из основных его достоинств.

Я не осуждаю эти подходы, но существуют и другие методы, которые могут оказаться 
при определенных условиях более эффективны. А теперь пристегните ремни.

## Производительность селекторов

Я прощаю то, что некоторые из вас начали качать головами в неодобрении увидев 
два астериска в селекторе `* + *` в начале статьи. Вот прецедент. 
[Универсальный селектор][4] это действительно мощный инструмент. И его можно 
использовать во благо, не только во зло. Прежде чем углубиться в это, однако,
я хотел бы обсудить проблему быстродействия.

Все исследования, которые мне довелось прочесть, включая исследования [Стива Шодерса][5]
(Steve Souders) и [Бена Фрэйна][6] (Ben Frain), пришли к выводу, что сравнительное
быстродействие CSS селекторов разных типов показывает, что разница пренебрежительно
мала. Фактически Фрэйн заключает, что «заморачиваться по поводу селекторов в 
современных браузерах бесполезно». И я пока не встречал ни одного убедительного
аргумента опровергающего результаты этих исследований.

Согласно Фрэйну, напротив, это количество CSS-селекторов, разрастание кода, может
привести к проблемам; особо он упоминает неиспользуемые, но объявленные css-правила. 
Другими словами, выбирать селекторы по классу за их «скорость» бесполезно, если
их количество это и есть то, что вызывает настоящие проблемы с производительностью. 
Ну, это, гигантские JPEGи и веб-шрифты, которые не были урезаны до необходимого
подмножества символов.

Наоборот, одновременный контроль множества элементов селектора `*` делает код 
лаконичнее, помогает уменьшить размер файла и улучшить производительность.

*Настоящая* проблема с универсальным селектором в том, что он сам по себе не 
представляет ничего, кроме «применяем стили, что бы это ни было». Фокус в том, 
как использовать его для создания более сложных селекторов, учитывающих контекст.

## Разбираемся с отступами

Проблема с ограничением области действия стилей до одного элемента в том, что не
все должно рассматриваться как *вещь в себе*. Например отступы: отступы это то,
что разделяет элементы. Само по себе применение верхнего отступа к элементу 
бессмысленно, вне зависимости от того как часто или редко ты это делаешь. Это 
все равно что намазать клеем одну сторону объекта до того как ты решишь его 
приклеить и определишься с тем, куда именно.

    .module-new {
      margin-bottom: 3em; /* что, каждый раз? */
    }


Что нам нужно, так это выражение (селектор), которое соответствует элементам,
которым нужен отступ. И это только элементы находящиеся в одном контексте с 
другими, соседними, элементами. [Селектор соседа][7] делает именно это: используя
форму `x + n`, мы можем добавить верхний отступ любому элементу `n`, перед которым
есть `x`. 

В обычном случае эта задача очень быстро приведет к описанию множества возможных 
случаев, если мы начнем создавать правила для каждого варианта соседства. Вот
почем мы используем вышеупомянутый универсальный селектор, создавая мордочку
совы. Аксиома следующая: «Все элементы в потоке, которые расположены после другого 
элемента, должны получить верхний отступ равный интерлиньяжу».

    * + * {
      margin-top: 1.5em;
    }

### Предрасположенность к ошибкам

Предполагая, что размер кегля шрифта параграфов `1 em` и интерлиньяж `1.5 em`,
устанавливаем отступ в одну строку всем элементам в потоке, которые следуют
за другим элементом в любых вариациях и в любом порядке. И мы, разработчики, и
ребята, которые создают контент проекта, можем не волноваться о том, что забыли
элемент и не прописали использование стандартного отступа, когда он идет после
другого элемента. Что бы добиться этого стандартными методами мы должны 
определять отступы для каждого отдельного элемента. Скучно, долго и 
предрасполагает к ошибкам.

Вместо того, что бы писать стили мы создали аксиому: всеобъемлющий принцип для 
лаяута с поточным контентом.

### Учитываем контекст


Можно сделать еще лучше. Применяя отступ исключительно между элементами мы не 
создаем никаких лишних отступов (ненужный клей), обреченных комбинироваться с 
полями родительского элемента. Сравните решение (a), которое добавляет верхний 
отступ ко всем элементам с решением (б), которое использует совиный селектор.

![Диаграмма][Элемент с отступами с и без использования совиного селектора]

Теперь давайте рассмотрим поведение с учетом вложенности. Как показано, при 
использовании совиного селектора и `margin-top` ни первый, ни последний элемент
не обладают ненужным отступом. Когда вы создаете подмножество таких элементов,
оборачивая их в родительский элемент, применяется то же правило. Никаких лишних
отступов вне зависимости от уровня вложенности. Это решение с некоторой 
элегантностью препятствует накоплению отступов в интерфейсе. 

![Диаграмма][Вложенные элементы с отступами с и без использования совиного селектора]

Это в высшей степени более лаконично и надежно, чем неаксиоматичный подход и 
необходимость подчищать лишний клей *постфактум*, как с неохотой признал Крис
Койер (Chris Coyier) в «[Отступы после модулей][10]». Именно эта статья,
надо заметить, подсказала мне идею лоботимированной совы.
 
    .module > *:last-child,
    .module > *:last-child > *:last-child,
    .module > *:last-child > *:last-child > *:last-child {
      margin: 0;
    }

Обратите внимание что все это работает только в контексте «модуля» (это была
большая просьба от редактора контента) и требует оценивать возможную степень 
вложенности. В данном случае до третьего уровня вложенности.

## Дизайн на основе исключений

Пока нам не потребовалось именовать ни один элемент. Мы просто написали правило.
Теперь мы можем воспользоваться достоинствами [низкого веса][11] совиного селектора
и начать вдумчиво добавлять исключения, используя достоинства каскада, вместо 
того, что бы осуждать его использование, как это происходит в других методах.

### Книжные параграфы с выключкой по ширине

    p {
      text-align: justify;
    }
    
    p + p {
    margin-top: 0;
    text-indent: 2em;
    }

Обратите внимание что абзацный отступ добавлен только тем параграфам, которые 
следуют за другими, что еще одна заслуга селектора ближайшего соседа.

### Компактные модули

    .compact * + * {
      margin-top: 0.75em;
    }

You can employ a little class-based object orientation if you like, to create a
reusable style for more compact modules. In this example, all elements that need
margin receive a margin of only half a line.

Можете насладиться небольшим отступом к объектно ориентированным методам, если
хотите, и создать небольшой приспособленный для повторного использования стиль
для компактных модулей. Например, все элементы которые требуют отступа получат
отступ только в половину интерлиньяжа.

### Виджеты с позиционированием

    .margins-off > * {
      margin-top: 0;
    }

Совиный селектор обладает низкой спецификой и будет применяться так же и к 
виджетам, таким как карты, где все позиционировано точно. Это — простой 
способ его отменить. Все чаще виджеты, вроде этого, исполняются в виде 
веб-компонент, в которых это правило все равно бы не наследовалось. Это происходит
благодаря [инкапсуляции стилей в теневом DOM][12].

## Красота `em`

Однако некоторые исключения неизбежны, из за использования единиц `em` для 
определения размера отступа, они уже сами по себе автоматически изменяются
из за другого свойства: `@media` запросов.

Когда доходит до заголовков, нам повезло несколько больше. Определив кегль шрифта 
заголовка в `em` мы сразу получаем соответствующий заголовку отступ (отступ лида) 
не написав ни единой дополнительной строки кода.

![Диаграмма][Автоматическое изменение отступа на основе кегля шрифта]


## Строчные элементы

Предполагается что объявленные стили должны наследоваться. Вот как это, и CSS
в целом, задумано. Однако я понимаю как раздражает многих из вас то, насколько
этот селектор жадный. Особенно после того, как эти люди привыкли избегать 
наследования насколько, насколько это вообще возможно. 

Я уже рассмотрел несколько исключений, которые вы, возможно захотите сделать, но
давайте пойдем дальше, помните, что строчные элементы со стандартным значением 
`display: inline` тоже унаследуют верхний отступ, но он не повлияет на их 
отображение. Строчные элементы принимают только горизонтальные отступы, что
является их стандартным поведением во всех браузерах.

![Диаграмма][Строчные элементы с отступом]

Если вы часто перезаписываете совиный селектор, то в дизайне могут быть 
глубокие системные проблемы. Совиный селектор работает с поточным контентом, 
и он должен быть основным на странице. Я бы не советовал сильно полагаться на
позиционированный контент в большинстве интерфейсов так как они нарушают неявное
взаимодействие элементов в рамках потока. Даже сетки, с их флоат-колонками не 
должны требовать чего то большего, чем простой селектор `.row > *`, применяющий
к ним `margin-top: 0`, что бы сбросить отступ. 

![Диаграмма][Флоат-элементы с отступом]


## Заключение

Я плохой математик, но [Начала Эвклида][16] произвели на меня большое 
впечатление: набор тривиальных правил, или аксиом, которые формируют основу для
сложного и прекрасного предмета геометрии. Благодаря Эвклиду я понимаю, что 
даже наиболее сложные системы должны быть основаны на элементарных правилах и
CSS тоже подпадает под это правило. Кроме того, разбиение на модули сложного 
интерфейса это необходимый шаг его взросления, любой интерфейс, который не 
следует базовым регулирующим его принципам, потеряет свою прозрачность. 

Совиный селектор дает вам контроль над поточным контентом, но кроме того это еще и
способ отказа от контроля. Стилизируя элементы в соответствии контексту и 
обстоятельствам мы принимаем то, что структура нашего контента является и должна
быть изменчивой. Вместо того что бы предопределять представление интерфейса в
целом мы позволяем определять его контенту. Мы возвращаем контроль людям, которые
его создают.

[1]: http://cssday.nl/2014
[2]: http://vimeo.com/101718785
[3]: http://www.impressivewebs.com/css-specificity-irrelevant/
[4]: http://meyerweb.com/eric/articles/webrev/200006a.html
[5]: http://www.stevesouders.com/blog/2009/03/10/performance-impact-of-css-selectors/
[6]: http://benfrain.com/css-performance-revisited-selectors-bloat-expensive-styles/
[7]: https://developer.mozilla.org/en-US/docs/Web/CSS/Adjacent_sibling_selectors
[10]: http://css-tricks.com/spacing-the-bottom-of-modules/
[11]: http://css-tricks.com/specifics-on-css-specificity/
[12]: http://frontender.info/shadowdom-201/
[16]: http://en.wikipedia.org/wiki/Euclidean_geometry#Axioms
[17]: http://alistapart.com/article/the-specialized-web-working-with-subject-matter-experts


[Элемент с отступами с и без использования совиного селектора]: img/owl_1.png "Элемент с отступами с и без использования совиного селектора"
[Вложенные элементы с отступами с и без использования совиного селектора]: img/owl_2.png "Вложенные элементы с отступами с и без использования совиного селектора"
[Автоматическое изменение отступа на основе кегля шрифта]: img/owl_3.png "Автоматическое изменение отступа на основе кегля шрифта"
[Строчные элементы с отступом]: img/owl_4.png "Строчные элементы с отступом"
[Флоат-элементы с отступом]: img/owl_5.png "Флоат-элементы с отступом"